import { isNotEmptyObject } from "@techmmunity/utils";
import { recursiveAutoGenerateEntityToDatabase } from "..";
import { EntityManager } from "../../../../entity-manager";
import { BaseConnectionOptions } from "../../../../connection/types/connection-options";
import { ColumnMetadata } from "../../../types/column-metadata";
import { DatabaseEvents } from "../../../types/database-events";
import { ClassType } from "../../../../types/class-type";

interface HandleCustomMetadataParams<Entity> {
	columnMetadata: ColumnMetadata;
	data: ClassType<Entity>;
	entityManager: EntityManager;
	acc: ClassType<Entity>;
	connectionOptions: BaseConnectionOptions;
	events: Array<DatabaseEvents>;
}

export const handleCustomMetadata = <Entity>({
	columnMetadata,
	data,
	entityManager,
	acc,
	connectionOptions,
	events,
}: HandleCustomMetadataParams<Entity>) => {
	const key = columnMetadata.name as keyof Entity;

	const value = data[key];

	if (!value) return acc;

	const subEntityMetadata = entityManager.getEntityMetadata(
		columnMetadata.type,
	);

	if (columnMetadata.isArray) {
		const generatedValue = (value as unknown as Array<any>).map(v =>
			// ALERT: Recursive call!!!
			recursiveAutoGenerateEntityToDatabase(
				{
					entityManager,
					connectionOptions,
				},
				{
					entity: subEntityMetadata,
					events,
					data: v,
				},
			),
		);

		acc[key] = generatedValue as any;
	} else {
		// ALERT: Recursive call!!!
		const generatedValue = recursiveAutoGenerateEntityToDatabase<Entity>(
			{
				entityManager,
				connectionOptions,
			},
			{
				entity: subEntityMetadata,
				events,
				data: value!,
			},
		);

		/**
		 * Only defines the new field if the autoGeneratedFields
		 * aren't just an empty object
		 */
		if (isNotEmptyObject(generatedValue)) {
			acc[key] = generatedValue!;
		}
	}
};
