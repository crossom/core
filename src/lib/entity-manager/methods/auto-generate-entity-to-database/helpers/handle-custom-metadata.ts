import { isNotEmptyObject } from "@techmmunity/utils";

import { recursiveAutoGenerateEntityToDatabase } from "..";

import type { EntityManager } from "../../../../entity-manager";

import type { BaseConnectionOptions } from "../../../../connection/types/connection-options";
import type { ColumnMetadata } from "../../../types/column-metadata";
import type { DatabaseEvents } from "../../../types/database-events";

interface HandleCustomMetadataParams {
	columnMetadata: ColumnMetadata;
	data: Record<string, any>;
	entityManager: EntityManager;
	acc: Record<string, any>;
	connectionOptions: BaseConnectionOptions;
	events: Array<DatabaseEvents>;
}

export const handleCustomMetadata = ({
	columnMetadata,
	data,
	entityManager,
	acc,
	connectionOptions,
	events,
}: HandleCustomMetadataParams) => {
	const key = columnMetadata.name;

	const value = data[key];

	if (!value) return acc;

	const subEntityMetadata = entityManager.getEntityMetadata(
		columnMetadata.type,
	);

	if (columnMetadata.isArray) {
		const generatedValue = (value as unknown as Array<any>).map(v =>
			// ALERT: Recursive call!!!
			recursiveAutoGenerateEntityToDatabase(
				{
					entityManager,
					connectionOptions,
				},
				{
					entity: subEntityMetadata,
					events,
					data: v,
				},
			),
		);

		acc[key] = generatedValue as any;
	} else {
		// ALERT: Recursive call!!!
		const generatedValue = recursiveAutoGenerateEntityToDatabase(
			{
				entityManager,
				connectionOptions,
			},
			{
				entity: subEntityMetadata,
				events,
				data: value!,
			},
		);

		/**
		 * Only defines the new field if the autoGeneratedFields
		 * aren't just an empty object
		 */
		if (isNotEmptyObject(generatedValue)) {
			acc[key] = generatedValue as any;
		}
	}
};
