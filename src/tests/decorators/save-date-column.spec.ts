import { SaveDateColumn } from "../../lib/decorators/save-date-column";
import { CompassError } from "../../lib/error";
import { CompassErrorCodeEnum } from "../../lib/error/types/error-code.enum";
import { MetadataUtil } from "../../lib/utils/metadata-util";

describe("Decorators > SaveDateColumn", () => {
	describe("Implicitly Type", () => {
		it("should add column metadata correctly (string)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should add column metadata correctly (number)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: number;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Number,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("number");
		});

		it("should add column metadata correctly (date)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: Date;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Date,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(columnMetadata.autoGenerate({}) instanceof Date).toBeTruthy();
		});
	});

	describe("Passing Options", () => {
		it("should define database name based on options", () => {
			class Test {
				@SaveDateColumn({
					name: "created_at",
				})
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "created_at",
					isAutoGenerated: true,
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});
	});

	describe("Errors", () => {
		it("should throw error if invalid type", () => {
			let result;

			try {
				class Test {
					@SaveDateColumn({
						name: "created_at",
					})
					public createdAt: Array<string>;
				}

				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				Test;
			} catch (err) {
				result = err;
			}

			expect(result instanceof CompassError).toBe(true);
			expect(result.message).toBe(
				"Auto Generated Date columns can only have simple types, ARRAYS, OBJECTS and CLASSES aren't supported",
			);
			expect(result.code).toBe(CompassErrorCodeEnum.INVALID_PARAM_TYPE);
			expect(result.origin).toBe("COMPASS");
			expect(result.details).toStrictEqual([
				"Entity: Test",
				"Column: createdAt",
			]);
		});
	});
});
