/* eslint-disable sonarjs/no-duplicate-string */

import { DeleteDateColumn } from "../../lib/decorators/date-columns/delete-date-column";
import { SaveDateColumn } from "../../lib/decorators/date-columns/save-date-column";
import { UpdateDateColumn } from "../../lib/decorators/date-columns/update-date-column";
import { CompassError } from "../../lib/error";
import { CompassErrorCodeEnum } from "../../lib/error/types/error-code.enum";
import { MetadataUtil } from "../../lib/utils/metadata-util";

describe("Decorators > DateColumns", () => {
	describe("Implicitly Type (DeleteDateColumn)", () => {
		it("should add column metadata correctly (string)", () => {
			class Test {
				@DeleteDateColumn()
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["delete"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should add column metadata correctly (number)", () => {
			class Test {
				@DeleteDateColumn()
				public createdAt: number;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["delete"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Number,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("number");
		});

		it("should add column metadata correctly (date)", () => {
			class Test {
				@DeleteDateColumn()
				public createdAt: Date;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["delete"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Date,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(columnMetadata.autoGenerate({}) instanceof Date).toBeTruthy();
		});
	});

	describe("Implicitly Type (SaveDateColumn)", () => {
		it("should add column metadata correctly (string)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should add column metadata correctly (number)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: number;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Number,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("number");
		});

		it("should add column metadata correctly (date)", () => {
			class Test {
				@SaveDateColumn()
				public createdAt: Date;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Date,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(columnMetadata.autoGenerate({}) instanceof Date).toBeTruthy();
		});
	});

	describe("Implicitly Type (UpdateDateColumn)", () => {
		it("should add column metadata correctly (string)", () => {
			class Test {
				@UpdateDateColumn()
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save", "update"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should add column metadata correctly (number)", () => {
			class Test {
				@UpdateDateColumn()
				public createdAt: number;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save", "update"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Number,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("number");
		});

		it("should add column metadata correctly (date)", () => {
			class Test {
				@UpdateDateColumn()
				public createdAt: Date;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "createdAt",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save", "update"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: Date,
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(columnMetadata.autoGenerate({}) instanceof Date).toBeTruthy();
		});
	});

	describe("Passing Options", () => {
		it("should define database name and extras based on options (DeleteDateColumn)", () => {
			class Test {
				@DeleteDateColumn({
					name: "created_at",
					extras: {
						foo: "bar",
					},
				})
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "created_at",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["delete"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
					extras: {
						foo: "bar",
					},
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should define database name and extras based on options (SaveDateColumn)", () => {
			class Test {
				@SaveDateColumn({
					name: "created_at",
					extras: {
						foo: "bar",
					},
				})
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "created_at",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
					extras: {
						foo: "bar",
					},
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});

		it("should define database name and extras based on options (UpdateDateColumn)", () => {
			class Test {
				@UpdateDateColumn({
					name: "created_at",
					extras: {
						foo: "bar",
					},
				})
				public createdAt: string;
			}

			const [columnMetadata] = MetadataUtil.getEntityMetadata({
				metadataKey: "columns",
				entity: Test,
			});

			expect(columnMetadata).toStrictEqual(
				expect.objectContaining({
					name: "createdAt",
					databaseName: "created_at",
					isAutoGenerated: true,
					autoGenerateOnlyOnEvents: ["save", "update"],
					autoGenerationType: "ENTITY_TO_DATABASE",
					type: String,
					extras: {
						foo: "bar",
					},
				}),
			);
			expect(typeof columnMetadata.autoGenerate).toBe("function");
			expect(typeof columnMetadata.autoGenerate({})).toBe("string");
		});
	});

	describe("Errors", () => {
		it("should throw error if invalid type", () => {
			let result;

			try {
				class Test {
					@SaveDateColumn({
						name: "created_at",
					})
					public createdAt: Array<string>;
				}

				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				Test;
			} catch (err) {
				result = err;
			}

			expect(result instanceof CompassError).toBe(true);
			expect(result.message).toBe(
				"Auto Generated Date columns can only have simple types, ARRAYS, OBJECTS and CLASSES aren't supported",
			);
			expect(result.code).toBe(CompassErrorCodeEnum.INVALID_PARAM_TYPE);
			expect(result.origin).toBe("COMPASS");
			expect(result.details).toStrictEqual([
				"Entity: Test",
				"Column: createdAt",
			]);
		});
	});
});
