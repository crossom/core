# To Do

- [x] Decide if the types of the arrays must be passed with or without []
  - Will be passed **without**
- [x] Add Suffix
- [x] Add Prefix
- [x] Add `extras` field to `@Entity` and all `@Column*` decorators
- [x] Add Error Thrower
  - [x] Export error thrower at `src/index.ts`
  - [x] Return errors at `src/decorators/column/helpers/get-type.ts`
- [x] Create a Logger
- [x] Uncomment tests validation at `.github/workflows/publish.yml`
- [x] Join metadata manager to connection, so users can use multiple connections
  - [x] Decorators stop using metadata manager and start using metadata again
  - [x] Review all of the files, to look how the things are being done and what have to be changed
  - [x] The metadata manager is created by the connection
- [x] Prefix and Suffix must be passed THE EXACT WAY that they are specified in the connection options, they MUST NOT be formatted
- [x] Change SubEntities
  - The sub-entities must be stored WITH THE ENTITIES, and not separately
  - To check if an entity has a table in the database, the metadata `isSubEntity` is used. If is a sub-entity, it DOESN'T has a table in the database
  - Update `EntityManager.convertEntityToDatabase`: If has the metadata `isSubEntity`, so the fields MUST NOT be affected by prefix or suffix
- [x] Add complex queries
  - [x] Not
  - [x] LessThan
  - [x] LessThanOrEqual
  - [x] MoreThan
  - [x] MoreThanOrEqual
  - [x] Like
  - [x] Between
  - [x] In
  - [x] IsNull
- [ ] Add Tests
  - [x] Decorators
  - [ ] EntityManager
  - [x] Error
  - [x] Logger
  - [x] Repository
    - [x] Find Operators
      - [x] LessThan
      - [x] LessThanOrEqual
      - [x] MoreThan
      - [x] MoreThanOrEqual
      - [x] Like
      - [x] Between
      - [x] In
      - [x] IsNull
      - [x] Not
  - [ ] Utils
    - [x] formatNamingPattern
    - [ ] MetadataUtil
      - [x] isDefaultMetadataType
      - [x] isCustomMetadataType
      - [x] isMetadataType
      - [x] hasEntityMetadata
      - [x] getEntityMetadata
      - [ ] defineEntityMetadata
      - [ ] defineAllEntityMetadata
      - [ ] getAllEntityMetadata
    - [x] formatPrefix
    - [x] formatSuffix
- [ ] Create method `EntityManager.convertDatabaseToEntity`
- [ ] Add the concept of "auto-generated" (Code -> Database) columns
  - [ ] Determine if is auto-generated by the database or by the plugin
  - [ ] Add `@SaveDateColumn` decorator
  - [ ] Add `@UpdateDateColumn` decorator
  - [ ] Add `@DeleteDateColumn` decorator
  - [ ] Add `@Version` decorator, that receives a param (string) that is the version (Ex: `@VersionColumn("v2")`)
  - [ ] Add auto-generated primary columns
- [ ] Add the concept of "auto-generated" (Database -> Code) columns
  - [ ] Add `@VirtualColumn` decorator
    - Will be applied to a class method, and will be generated after a query from database
    - Remember to check: If the `select` be passed, so verify if the virual field in the array
  - [ ] Edit the auto-generation method of primary columns
- [ ] Uncomment tests validation at `jest.config.js`
- [ ] Add pipeline step to check if mandatory files has changes
  - Maybe this action can be used: https://github.com/marketplace/actions/get-all-changed-files
  - Mandatory files: CHANGELOG.md, package.json
- [ ] Improve Documentation
  - Like [TypeORM docs](https://github.com/typeorm/typeorm#step-by-step-guide)
  - [ ] Use [Docusaurus](https://docusaurus.io/docs)
  - [ ] Give a bit of love to `CONTRIBUTING.md`
  - [ ] Add COMPLETE documentation about HOW to create a plugin
    - Include EVERY validation that need to be done
    - Include EVERY step IN ORDER that need to be made
  - [ ] Create a markdown table with ALL the features of the ORM, so the plugins can specify EVERY feature that they have implemented

## To Do Future

### General

- [ ] Add `@Index` decorator
- [ ] Add entities auto-import from string path, like TypeORM
  - Use `process.cwd()` to get the root dir of the project

### CLI

- [ ] Add "migrations"
  - Add a way to generate "tables" (Run a command that uses the plugin config to generate a new migration file based on the entities data)
  - This can be used for SQL and NoSql databases (Ex: PostgreSQL & Dynamo)

## Discarded Ideas

- Add `@SubEntity` decorator
  - What if a entity be an entity and also a subEntity? This may cause a lot of bugs, so it's better think another way to handle this, with only one decorator
- Add `@SecondaryColumn` decorator (This will be used in cases like `DynamoDB - sortKey`)
  - `extras` field will be used
