# To Do

- [x] Decide if the types of the arrays must be passed with or without []
  - As they are the only type who need to be passed, will be passed **without**
- [x] Add Suffix
- [x] Add Prefix
- [x] Add `extras` field to `@Entity` and all `@Column*` decorators
- [x] Add Error Thrower
  - [x] Export error thrower at `src/index.ts`
  - [x] Return errors at `src/decorators/column/helpers/get-type.ts`
- [x] Create a Logger
- [x] Uncomment tests validation at `.github/workflows/publish.yml`
- [x] Join metadata manager to connection, so users can use multiple connections
  - [x] Decorators stop using metadata manager and start using metadata again
  - [x] Review all of the files, to look how the things are being done and what have to be changed
  - [x] The metadata manager is created by the connection
- [x] Prefix and Suffix must be passed THE EXACT WAY that they are specified in the connection options, they MUST NOT be formatted
- [x] Change SubEntities
  - The sub-entities must be stored WITH THE ENTITIES, and not separately
  - To check if an entity has a table in the database, the metadata `isSubEntity` is used. If is a sub-entity, it DOESN'T has a table in the database
  - Update `EntityManager.convertEntityToDatabase`: If has the metadata `isSubEntity`, so the fields MUST NOT be affected by prefix or suffix
- [x] Add complex queries
  - [x] Not
  - [x] LessThan
  - [x] LessThanOrEqual
  - [x] MoreThan
  - [x] MoreThanOrEqual
  - [x] Like
  - [x] Between
  - [x] In
  - [x] IsNull
- [x] Add Tests
  - [x] Decorators
  - [x] EntityManager
    - [x] Initialization (verify if it is setting ENTITIES and SUB-ENTITIES correctly)
    - [x] getAllEntitiesMetadata
    - [x] getAllTablesMetadata
    - [x] getEntityMetadata
    - [x] getColumnMetadata
    - [x] getEntityPrimaryColumns
    - [x] convertEntityToDatabase
  - [x] Error
  - [x] Logger
  - [x] Repository
    - [x] Find Operators
      - [x] LessThan
      - [x] LessThanOrEqual
      - [x] MoreThan
      - [x] MoreThanOrEqual
      - [x] Like
      - [x] Between
      - [x] In
      - [x] IsNull
      - [x] Not
  - [x] Utils
    - [x] formatNamingStrategy
    - [x] MetadataUtil
      - [x] isDefaultMetadataType
      - [x] isCustomMetadataType
      - [x] isMetadataType
      - [x] hasEntityMetadata
      - [x] getEntityMetadata
      - [x] defineEntityMetadata
      - [x] defineAllEntityMetadata
      - [x] getAllEntityMetadata
      - [x] addColumnMetadataToEntity
    - [x] formatPrefix
    - [x] formatSuffix
  - [x] Validate if optional columns (ex: `column?: string`) get the correct tipping
- [x] Create method `addColumnMetadataToEntity` at `MetadataUtil`, and filter undefined fields before add the column
- [x] Add system to verify if the user has passed a custom entity / column name, and DON'T format it based on the naming pattern / prefix-suffix
- [x] Create method `EntityManager.convertDatabaseToEntity`
- [x] Uncomment tests validation at `jest.config.js`
- [x] Add pipeline step to check if mandatory files has changes
  - Mandatory files:
    - CHANGELOG.md
    - package.json
- [x] Add the concept of "auto-generated" (Code -> Database) columns
  - [x] Determine if is auto-generated by the database or by the plugin
  - [x] Add `@PrimaryGeneratedColumn` decorator
    - [x] Make `autoGenerateEntityToDatabase` method generate values based on the column metadata
  - [x] Add `@SaveDateColumn` decorator
  - [x] Add `@UpdateDateColumn` decorator
  - [x] Add `@DeleteDateColumn` decorator
  - [x] Add validation at `autoGenerateEntityToDatabase` to validate if the column should be auto-generated based on event
- [x] Add `Exist` operator, to verify if a field doesn't exists
- [ ] Add tests to `src/utils/validations`
- [x] Review code to check if is possible to split params in injectables and not injectables
- [x] Unbind methods that receive `this`, change to receive the functions of the class instead, and make the methods PRIVATE
- [ ] Create a template repository "compass-plugin"
- [x] Improve Documentation
  - Like [TypeORM docs](https://github.com/typeorm/typeorm#step-by-step-guide)
  - [x] Use [Docusaurus](https://docusaurus.io/docs)
  - [x] Give a bit of love to `CONTRIBUTING.md`
  - [ ] Add COMPLETE documentation about HOW to create a plugin
    - Include EVERY validation that need to be done
    - Include EVERY step IN ORDER that need to be made
  - [ ] Create a markdown table with ALL the features of the ORM, so the plugins can specify EVERY feature that they have implemented
  - [ ] Create tutorials
    - [ ] "how to work with multiple value types for the same field"
    - [ ] "how to work with the same table for multiple entities" / "how to work with a table that have multiple entities schemas"
    - [ ] "how to work with array columns that can have multiple types" (Ex: `column: Array<Entity1 | Entity2>`)
- [ ] Add "Save Operators"
  - [ ] `Remove` -> deletes a field

## To Do Future

### General

- [ ] Add `@Index` decorator
- [ ] Add `@Version` decorator, that receives a param (string) that is the version (Ex: `@VersionColumn("v2")`)
  - This column will be auto-generated **on save**
- [ ] Add entities auto-import from string path, like TypeORM
  - https://preview.npmjs.com/package/glob
- [ ] Add the concept of "auto-generated" (Database -> Code) columns
  - [ ] Add `@VirtualColumn` decorator
    - Will be applied to a class method, and will be generated after a query from database
    - Remember to check: If the `select` be passed, so verify if the virtual field in the array
  - [ ] Edit the auto-generation method of primary columns
- [ ] Maybe in the future accept more column type and handle the correspondent function automatically? Types like accept "bigint" as param for @Column, convert this automatically to Number, and store the "bigint" at the "extras" field, so relational databases can take more advantage of this package

### SQL

- [ ] Add `@JoinColumn` decorator
- [ ] Add `@JoinTable` decorator
- [ ] Add `@OneToOne` decorator
- [ ] Add `@OneToMany` decorator
- [ ] Add `@ManyToMany` decorator
- [ ] Add support to Enums (currently, it already works with enums, but it doesn't saves the enums values. The `Column` decorator need to be modified to accept an enum too, and use `Object.values` to get the **VALUES** of the array)

### CLI

- [ ] Add "migrations"
  - Add a way to generate "tables" (Run a command that uses the plugin config to generate a new migration file based on the entities data)
  - This can be used for SQL and NoSql databases (Ex: PostgreSQL & Dynamo)

## Discarded Ideas

- Add `@SubEntity` decorator
  - What if a entity be an entity and also a subEntity? This may cause a lot of bugs, so it's better think another way to handle this, with only one decorator
- Add `@SecondaryColumn` decorator (This will be used in cases like `DynamoDB - sortKey`)
  - `extras` field will be used
