# To Do

## Alpha

- [x] Decide if the types of the arrays must be passed with or without []
  - As they are the only type who need to be passed, will be passed **without**
- [x] Add Suffix
- [x] Add Prefix
- [x] Add `extras` field to `@Entity` and all `@Column*` decorators
- [x] Add Error Thrower
  - [x] Export error thrower at `src/index.ts`
  - [x] Return errors at `src/decorators/column/helpers/get-type.ts`
- [x] Create a Logger
- [x] Uncomment tests validation at `.github/workflows/publish.yml`
- [x] Join metadata manager to connection, so users can use multiple connections
  - [x] Decorators stop using metadata manager and start using metadata again
  - [x] Review all of the files, to look how the things are being done and what have to be changed
  - [x] The metadata manager is created by the connection
- [x] Prefix and Suffix must be passed THE EXACT WAY that they are specified in the connection options, they MUST NOT be formatted
- [x] Change SubEntities
  - The sub-entities must be stored WITH THE ENTITIES, and not separately
  - To check if an entity has a table in the database, the metadata `isSubEntity` is used. If is a sub-entity, it DOESN'T has a table in the database
  - Update `EntityManager.convertEntityToDatabase`: If has the metadata `isSubEntity`, so the fields MUST NOT be affected by prefix or suffix
- [x] Add complex queries
  - [x] Not
  - [x] LessThan
  - [x] LessThanOrEqual
  - [x] MoreThan
  - [x] MoreThanOrEqual
  - [x] Like
  - [x] Between
  - [x] In
  - [x] IsNull
- [x] Add Tests
  - [x] Decorators
  - [x] EntityManager
    - [x] Initialization (verify if it is setting ENTITIES and SUB-ENTITIES correctly)
    - [x] getAllEntitiesMetadata
    - [x] getAllTablesMetadata
    - [x] getEntityMetadata
    - [x] getColumnMetadata
    - [x] getEntityPrimaryColumns
    - [x] convertEntityToDatabase
  - [x] Error
  - [x] Logger
  - [x] Repository
    - [x] Find Operators
      - [x] LessThan
      - [x] LessThanOrEqual
      - [x] MoreThan
      - [x] MoreThanOrEqual
      - [x] Like
      - [x] Between
      - [x] In
      - [x] IsNull
      - [x] Not
  - [x] Utils
    - [x] formatNamingStrategy
    - [x] MetadataUtil
      - [x] isDefaultMetadataType
      - [x] isCustomMetadataType
      - [x] isMetadataType
      - [x] hasEntityMetadata
      - [x] getEntityMetadata
      - [x] defineEntityMetadata
      - [x] defineAllEntityMetadata
      - [x] getAllEntityMetadata
      - [x] addColumnMetadataToEntity
    - [x] formatPrefix
    - [x] formatSuffix
  - [x] Validate if optional columns (ex: `column?: string`) get the correct tipping
- [x] Create method `addColumnMetadataToEntity` at `MetadataUtil`, and filter undefined fields before add the column
- [x] Add system to verify if the user has passed a custom entity / column name, and DON'T format it based on the naming pattern / prefix-suffix
- [x] Create method `EntityManager.convertDatabaseToEntity`
- [x] Uncomment tests validation at `jest.config.js`
- [x] Add pipeline step to check if mandatory files has changes
  - Mandatory files:
    - CHANGELOG.md
    - package.json
- [x] Add the concept of "auto-generated" (Code -> Database) columns
  - [x] Determine if is auto-generated by the database or by the plugin
  - [x] Add `@PrimaryGeneratedColumn` decorator
    - [x] Make `autoGenerateEntityToDatabase` method generate values based on the column metadata
  - [x] Add `@SaveDateColumn` decorator
  - [x] Add `@UpdateDateColumn` decorator
  - [x] Add `@DeleteDateColumn` decorator
  - [x] Add validation at `autoGenerateEntityToDatabase` to validate if the column should be auto-generated based on event
- [x] Add `Exist` operator, to verify if a field doesn't exists
- [x] Review code to check if is possible to split params in injectables and not injectables
- [x] Unbind methods that receive `this`, change to receive the functions of the class instead, and make the methods PRIVATE
- [x] Fix build script
- [x] Add tests to `src/lib/utils/validations`
- [x] Add `EntityManager.convertColumnsNames`
  - Will convert a array of strings into an array of strings with the database columns manes
- [x] Add `select` option conversion at `beforeFind`
- [x] Add `EntityManager.formatOrder`
  - Will convert an object with columns order to the database names
- [x] Add `order` option conversion at `beforeFind`
- [x] Fix all `after*` commands to return the correct value
  - [x] `afterSave`
  - [x] `afterInsert`
  - [x] `afterUpdate`
  - [x] `afterUpsert`
- [x] Add before and after methods
  - [x] save
  - [x] insert
  - [x] update
  - [x] upsert
  - [x] find
  - [x] findOne
  - [x] delete
  - [x] softDelete
  - [x] recover
  - [x] count
  - [x] performativeCount
- [x] Create a template repository "symbiosis-plugin"

### General

- [x] Review column name converter
  - SubEntity columns also should be converted?
    - Yes, they will be converted, only the prefixes aren't will be applied
- [x] Add "comment" option to "@Column" decorator
  - Will receive a comment about the column
- [x] Add "enum" option to "@Column" decorator
  - Will receive a enum and get it's values
- [x] Add "defaultValue" option to "@Column" decorator
  - Will receive the default value of the column
- [x] Add `@Index` decorator
- [x] Add "index" to FindOptions
- [x] Add "databaseType" to ColumnOptions
- [x] Add "Save Operators"
  - [x] `Remove` -> deletes a column from a record
  - [x] `Plus` -> Sets the value of a column as itself + the value passed as param
  - [x] `Minus` -> Sets the value of a column as itself - the value passed as param
  - [x] `Append` -> Add element to the end of a list
  - [x] `Min` -> Changes the value of the column ONLY IF it's greater than the value specified
  - [x] `Max` -> Changes the value of the column ONLY IF it's lower than the value specified
  - [x] `IfNotExists` -> Only sets the column if it NOT already exists
  - [x] `Pop` -> Removes and item from a list
- [x] Change the way that prefix and suffix work
  - EntityToDatabase -> Will be applied BEFORE the naming strategy
  - DatabaseToEntity -> Will be applied AFTER the naming strategy
- [x] Make the `@PrimaryColumn*` decorators accept only `string` and `number` as types
- [x] Add entities auto-import from string path, like TypeORM
  - https://www.npmjs.com/package/glob
- [x] Edit the auto-generation method of primary columns
- [x] Add `SubEntity` decorator
  - Will replace `@Entity({ isSubEntity: true })` to make things more explicity
  - [SOLVED] What if a entity be an entity and also a subEntity? If the entity is both an entity and sub-entity, you can use the `@Entity` decorator as always. Both types of entities are handled in the same way, with the only differece beign having a table in the database or not.
- [x] Refact "auto-generation"
  - Remember to remove the "todo" test
- [x] Add `@CountUpdateColumn` that receives **NO PARAMS**
  - Only accepts "number" type
  - This column will be auto-generated **on update**
  - The value of this column will be the SaveOperator `Plus(1)`
- [x] Refact `@CountUpdateColumn` to be `@CountColumn`
  - Will receive a parameter `events`, an array of events to increment the count
- [ ] Add colors to the logs, like Nestjs Logger
- [ ] Add `@VersionColumn` that receives the version (Ex: `@VersionColumn("v2")`)
  - Only accepts "string" type
  - This column will be auto-generated **on save**
- [ ] Add `@RunBefore`
  - Will recieve 1 parameter (save, find, update, delete)
  - Will be aplied to entity methods
  - Will run before an event
  - The method will recieve 3 parameters
    - conditions
    - data
    - options
  - Try to make a `Entity` type, that ignores `runBefore` methods
- [ ] Add `@RunAfter`
  - Will recieve 1 parameter (save, find, update, delete)
  - Will be aplied to entity methods
  - Will run after an event
  - The method will recieve 3 parameters
    - conditions
    - data
    - options
  - Try to make a `Entity` type, that ignores `runAfter` methods

### Docs

- [ ] Fix verify mandatory files workflow
- [ ] Improve Documentation
  - Like [TypeORM docs](https://github.com/typeorm/typeorm#step-by-step-guide)
  - [x] Use [Docusaurus](https://docusaurus.io/docs)
  - [x] Give a bit of love to `CONTRIBUTING.md`
  - [ ] Add COMPLETE documentation about HOW to create a plugin
    - Include EVERY validation that need to be done
    - Include EVERY step IN ORDER that need to be made
  - [ ] Create a markdown table with ALL the features of the ORM, so the plugins can specify EVERY feature that they have implemented
  - [ ] Create tutorials
    - [ ] "how to work with multiple value types for the same field"
    - [ ] "how to work with the same table for multiple entities" / "how to work with a table that have multiple entities schemas"
    - [ ] "how to work with array columns that can have multiple types" (Ex: `column: Array<Entity1 | Entity2>`)

### SQL

#### Requirements

- [SOLVED] Primary columns can be foreign keys
  - It will be handled by `OneToOne`, etc
- On insert, also insert relations
- Postgres Composite PK-FK
  - https://stackoverflow.com/questions/9984022/postgres-fk-referencing-composite-pk

```sql
CREATE TABLE bar (
    id SERIAL,
    bar_created_on ABSTIME,
    bar_deactivated_on ABSTIME,
    foo_id INTEGER NOT NULL,
    foo_created_on ABSTIME NOT NULL,
    FOREIGN KEY (foo_id, foo_created_on) REFERENCES foo (id, foo_created_on),
    PRIMARY KEY (id, bar_created_on)
);
```

**Entity that can hold the foreign key**

|              | current | target | a third one |
| ------------ | :-----: | :----: | :---------: |
| one to one   |    x    |        |             |
| one to one   |         |   x    |             |
| one to many  |         |   x    |             |
| many to one  |    x    |        |             |
| many to many |         |        |      x      |

#### Tasks

- [x] Add support to Enums (currently, it already works with enums, but it doesn't saves the enums values. The `Column` decorator need to be modified to accept an enum too, and use `Object.values` to get the **VALUES** of the array)
  - [x] Add "enum" option to "@Column" decorator
    - Will receive an enum to get it's values
- [x] Add `@OneToOne` decorator
  - Entity Decorator
  - Used to specify that a table has a relation with another table
  - Metadata
    type: "ONE_TO_ONE" | "ONE_TO_MANY" | "MANY_TO_ONE"
    targetEntity: [Entity class]
    relationMap: { [current entity column]: [target entity column] }
- [x] Add `@OneToMany` decorator
- [x] Add `@ManyToOne` decorator
- [ ] Add `@ManyToMany` decorator

### CLI

- [x] Add "migrations"
  - Add a way to generate "tables" (Run a command that uses the plugin config to generate a new migration file based on the entities data)
  - This can be used for SQL and NoSql databases (Ex: PostgreSQL & Dynamo)

## Discarded Ideas

- Add `@SecondaryColumn` decorator (This will be used in cases like `DynamoDB - sortKey`)
  - `extras` field will be used
- Maybe in the future accept more column type and handle the correspondent function automatically? Types like accept "bigint" as param for @Column, convert this automatically to Number, and store the "bigint" at the "extras" field, so relational databases can take more advantage of this package
  - No, the option "databaseType" was added to this purpose
